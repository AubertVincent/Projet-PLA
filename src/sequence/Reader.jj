/**
* JavaCC
*/
options
{
  static = true;
  DEBUG_PARSER = false;
  DEBUG_TOKEN_MANAGER = false ;
}

PARSER_BEGIN(Reader)
package reader;
import java.io.*;
import java.nio.charset.StandardCharsets;
import carte.*;
import entite.*;
import gui.*;
import moteurDuJeu.*;
import operateur.*;
import personnages.*;
import pickable.*;
import sequence.*;


public class Reader
{
  //TODO Mettre un return pour retourner l'arbre et modifier le nom de la fonction
  public static void main(String [] args)
  {
    String str = Test.giveString();
	Reader parser = new Reader(new ByteArrayInputStream(str.getBytes(StandardCharsets.UTF_8)));
	try
	{
	  _Sequence resultingSequence = Reader.SEQUENCE();
	}
	catch (Exception e)
	{
	  System.out.println("NOK");
	  System.out.println(e.getMessage());
	  Reader.ReInit(new ByteArrayInputStream(str.getBytes(StandardCharsets.UTF_8)));
	}
	catch (Error e)
	{
	  System.out.println("Oops");
	  System.out.println(e.getMessage());
	}
    //return _Sequence ;
  }
}

PARSER_END(Reader)


// les caractères ignorés
SKIP :
{
  " "
| "\t"
| "\r"
| "\n" 
| "\u0001"
| "\u0002"
| "\u0003"
| "\u0004"
| "\u0005"
| "\u0006"
| "\u0007"
| "\u0008"
| "\u000b"
| "\u000c"
| "\u000e"
| "\u000f"
| "\u0010"
| "\u0011"
| "\u0012"
| "\u0013"
| "\u0014"
| "\u0015"
| "\u0016"
| "\u0017"
| "\u0018"
| "\u0019"
| "\u001a"
| "\u001b"
| "\u001c"
| "\u001d"
| "\u001e"
| "\u001f"
| "\u007f"
}

MORE :
{
  "//" : IN_SL_COMMENT
| "/*" : IN_ML_COMMENT
}

< IN_SL_COMMENT >
SPECIAL_TOKEN :
{
  < SL_COMMENT :
    "\n"
  | "\r"
  | "\r\n" > : DEFAULT
}

< IN_ML_COMMENT >
SPECIAL_TOKEN :
{
  < ML_COMMENT : "*/" > : DEFAULT
}

< IN_SL_COMMENT, IN_ML_COMMENT >
SKIP :
{
  < ~[ ] >
} // les lexèmes du langage

TOKEN :
{
 < A : "A" >
| < M : "M" >
| < C : "C" >
| < S : "S" >
| < R : "R" >
| < T : "T" >
| < N : "N" >
| < W : "W" >
| < E : "E" >
|   < LETTER : [ "a"-"z", "A"-"Z" ] >
| < DIGIT : [ "0"-"9" ] >
| < LPAR : "(" >
| < RPAR : ")" >
| < BARRE : "|" >
| < SEMICOLON : ";" >
| < CHEVRON : ">" >
| < ID :
    (
      < LETTER >
    | < DIGIT >
    )+ >
| < OP :
    (
      < BARRE >
    | < SEMICOLON >
    | < CHEVRON >
    ) 
  >
}




Operator OP() :
{
}
{
  < BARRE >
  {
    return new RandomBar(); 
  }
| < SEMICOLON >
  {
    return new Succession();
  }
| < CHEVRON >
  {
    return new Priority();
  }
  // TODO : Add other behaviors 
}

_Sequence SEQUENCE() :
{
  Action act ;
  Operator op ;
  _Sequence left, right ;
}
{
  < LPAR > left = SEQUENCE() op = OP() right = SEQUENCE() < RPAR >
	{
	return Tree(op, left, right) ;
	}

| act = ACTION()
	{
	return act;
	}
}

Action ACTION():
{
	Movement mov ;
}
{
  < M > mov = MOVEMENT()
  {
	return mov ;
  }
| < A > att = ATT()
  {
	return att ;
  }
// Add rest of grammar  
}

Attack ATT() :
{
}
{
	< C >
	{
	  return new ClassicAck();
	}
| 	< S >
	{
	  return new SuicideBomber();
	}
}

Movement MOVEMENT() :
{
  	int len ;
	int x, y;
	Direction dir;
}
{
	< C > len = < DIGIT > dir = DIRECTION()
	{
	  return new MoveDir(dir, len);
	}
| < R > len = < DIGIT >
	{
	  return new Recall(len);
	}
| < T > x = < DIGIT > y = < DIGIT >
	{
	  return new Tunnel(x, y);
	}
}

Direction DIRECTION() : 
{
}
{
	< N >
	{
	  return new Direction(NORTH);
	}
	< W >
	{
	  return new Direction(WEST);
	}
	< S >
	{
	  return new Direction(SOUTH);
	}
	< E >
	{
	  return new Direction(EAST);
	}	  	
}